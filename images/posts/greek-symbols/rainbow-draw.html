<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Rainbow Gradient Draw</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  /* Page background + safe top padding */
  html, body {
    height: 100%;
    margin: 0;
    padding: 0;
    background: #f5f5f5; /* restored background */
    overflow: hidden;    /* prevent inner scrollbars inside iframe */
  }

  /* outer container - centers the wrapper in the iframe */
  body {
    display: flex;
    justify-content: center;
    align-items: flex-start; /* top aligned so top padding works */
    padding-top: 10px;       /* tiny buffer at top */
    box-sizing: border-box;
  }

  /* wrapper: the thing we measure and center */
  #wrapper {
    width: 95%;           /* side padding on small screens */
    max-width: 800px;     /* desktop max width */
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    align-items: center;  /* center canvas and button horizontally */
    gap: 10px;
    padding: 8px;         /* optional inner padding */
    background: transparent;
  }

  /* responsive canvas */
  canvas {
    width: 100%;
    display: block;       /* remove inline spacing */
    border: 1px solid #ccc;
    cursor: crosshair;
    touch-action: none;   /* prevent scrolling while drawing */
    box-sizing: border-box;
  }

  /* centered button */
  #refreshButton {
    padding: 10px 20px;
    font-size: 16px;
    cursor: pointer;
    align-self: center;
  }
</style>
</head>
<body>
  <div id="wrapper">
    <canvas id="canvas" width="800" height="600"></canvas>
    <button id="refreshButton">Refresh Canvas</button>
  </div>

<script>
/* ----------------------------
   Drawing + resize + messaging
   ---------------------------- */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const wrapper = document.getElementById('wrapper');
const refreshBtn = document.getElementById('refreshButton');

let drawing = false;
let points = [];
let hue = 0;
const aspect = 3/4; // canvas height = width * aspect (4:3 width:height is width*0.75)

/* debounce helper so parent doesn't get rapid messages */
function debounce(fn, wait = 50) {
  let t = null;
  return (...args) => {
    clearTimeout(t);
    t = setTimeout(() => fn(...args), wait);
  };
}

/* Resize the canvas internal resolution to match its displayed (CSS) size.
   We use getBoundingClientRect so we match the actual rendered width.
*/
function resizeCanvasToDisplay() {
  const rect = canvas.getBoundingClientRect();
  const displayWidth = Math.max(1, Math.round(rect.width));
  const desiredHeight = Math.round(displayWidth * aspect);

  if (canvas.width !== displayWidth || canvas.height !== desiredHeight) {
    // Setting internal pixel size clears content â€” that's fine for this drawing app
    canvas.width = displayWidth;
    canvas.height = desiredHeight;
  }
}

/* Draw interpolated rainbow segment (same smooth algorithm you liked) */
function drawLineSegment(p1, p2) {
  const dx = p2.x - p1.x;
  const dy = p2.y - p1.y;
  const distance = Math.hypot(dx, dy);
  const steps = Math.max(1, Math.ceil(distance / 2)); // smaller -> smoother

  for (let i = 0; i < steps; i++) {
    const t = i / steps;
    const x = p1.x + dx * t;
    const y = p1.y + dy * t;
    const nextT = (i + 1) / steps;
    const nextX = p1.x + dx * nextT;
    const nextY = p1.y + dy * nextT;

    const gradient = ctx.createLinearGradient(x, y, nextX, nextY);
    gradient.addColorStop(0, `hsl(${hue}, 100%, 50%)`);
    gradient.addColorStop(1, `hsl(${(hue + 5) % 360}, 100%, 50%)`);

    ctx.strokeStyle = gradient;
    ctx.lineWidth = 8;
    ctx.lineCap = 'round';

    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(nextX, nextY);
    ctx.stroke();

    hue = (hue + 0.5) % 360; // user-specified slower increment
  }
}

/* Safe touch position relative to canvas */
function getTouchPos(touchEvent) {
  const rect = canvas.getBoundingClientRect();
  const touch = touchEvent.touches[0] || touchEvent.changedTouches[0];
  return {
    x: touch.clientX - rect.left,
    y: touch.clientY - rect.top
  };
}

/* -------------------------
   Mouse event handlers
   ------------------------- */
canvas.addEventListener('mousedown', (e) => {
  drawing = true;
  points.push({ x: e.offsetX, y: e.offsetY });
});
canvas.addEventListener('mousemove', (e) => {
  if (!drawing) return;
  const p2 = { x: e.offsetX, y: e.offsetY };
  const p1 = points[points.length - 1];
  if (p1) drawLineSegment(p1, p2);
  points.push(p2);
});
window.addEventListener('mouseup', () => {
  drawing = false;
  points = [];
});

/* -------------------------
   Touch event handlers
   ------------------------- */
canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  drawing = true;
  points.push(getTouchPos(e));
});
canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  if (!drawing) return;
  const p2 = getTouchPos(e);
  const p1 = points[points.length - 1];
  if (p1) drawLineSegment(p1, p2);
  points.push(p2);
});
canvas.addEventListener('touchend', () => {
  drawing = false;
  points = [];
});
canvas.addEventListener('touchcancel', () => {
  drawing = false;
  points = [];
});

/* -------------------------
   Refresh button
   ------------------------- */
refreshBtn.addEventListener('click', () => {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  hue = 0; // reset hue per request
  // resizing might not have changed the wrapper height, but we re-run notification
  debouncedNotifyParent();
});

/* -------------------------
   Parent iframe resizing
   ------------------------- */
let lastSentHeight = 0;
function notifyParentOfHeight() {
  // measure only the wrapper - avoids the infinite growth spiral
  const h = Math.ceil(wrapper.getBoundingClientRect().height);
  if (h && h !== lastSentHeight) {
    lastSentHeight = h;
    // send to parent (parent should listen for messages and set iframe height)
    window.parent.postMessage({ type: 'resize-iframe', height: h }, '*');
  }
}
const debouncedNotifyParent = debounce(notifyParentOfHeight, 60);

/* Resize both canvas and notify parent (keeps iframe fit) */
function fullResize() {
  resizeCanvasToDisplay();
  // slight delay to ensure layout has settled before measuring
  setTimeout(debouncedNotifyParent, 30);
}

/* run on load and when window resizes */
window.addEventListener('load', () => {
  fullResize();
});
window.addEventListener('resize', () => {
  fullResize();
});

/* In case fonts or rendering change layout, call notify after a short idle */
setTimeout(debouncedNotifyParent, 200);

/* Also notify parent when user finishes drawing (some mobile browsers cause layout changes) */
canvas.addEventListener('mouseup', debouncedNotifyParent);
canvas.addEventListener('touchend', debouncedNotifyParent);
</script>
</body>
</html>
