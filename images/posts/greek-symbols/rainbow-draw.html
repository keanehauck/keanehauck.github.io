<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Rainbow Gradient Draw</title>
<style>
  body {
    display: flex;
    justify-content: center;
    align-items: flex-start; /* align top */
    min-height: 100vh;
    margin: 0;
    background: #f5f5f5;
    padding-top: 10px; /* tiny buffer at top */
  }

  .container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    width: 95%;
    max-width: 800px;
  }

  canvas {
    border: 1px solid #ccc;
    cursor: crosshair;
    width: 100%;       
    display: block;
    touch-action: none; 
  }

  button {
    padding: 10px 20px;
    font-size: 16px;
    cursor: pointer;
  }
</style>
</head>
<body>

<div class="container">
  <canvas id="canvas" width="800" height="600"></canvas>
  <button id="refreshButton">Refresh Canvas</button>
</div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

let drawing = false;
let points = [];
let hue = 0;

// Resize canvas to match displayed width while keeping 4:3 aspect ratio
function resizeCanvas() {
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width;
  canvas.height = rect.width * 0.75; // 4:3 aspect ratio
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Get touch position relative to canvas
function getTouchPos(canvas, touchEvent) {
  const rect = canvas.getBoundingClientRect();
  return {
    x: touchEvent.touches[0].clientX - rect.left,
    y: touchEvent.touches[0].clientY - rect.top
  };
}

// Draw interpolated rainbow segment
function drawLineSegment(p1, p2) {
  const dx = p2.x - p1.x;
  const dy = p2.y - p1.y;
  const distance = Math.hypot(dx, dy);
  const steps = Math.ceil(distance / 2); // smaller = smoother

  for (let i = 0; i < steps; i++) {
    const t = i / steps;
    const x = p1.x + dx * t;
    const y = p1.y + dy * t;
    const nextT = (i + 1) / steps;
    const nextX = p1.x + dx * nextT;
    const nextY = p1.y + dy * nextT;

    const gradient = ctx.createLinearGradient(x, y, nextX, nextY);
    gradient.addColorStop(0, `hsl(${hue}, 100%, 50%)`);
    gradient.addColorStop(1, `hsl(${(hue + 5) % 360}, 100%, 50%)`);

    ctx.strokeStyle = gradient;
    ctx.lineWidth = 8;
    ctx.lineCap = 'round';

    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(nextX, nextY);
    ctx.stroke();

    hue = (hue + 0.5) % 360; // slower increment
  }
}

// --- Mouse events ---
canvas.addEventListener('mousedown', e => {
  drawing = true;
  points.push({x: e.offsetX, y: e.offsetY});
});

canvas.addEventListener('mousemove', e => {
  if (!drawing) return;
  const p2 = {x: e.offsetX, y: e.offsetY};
  const p1 = points[points.length - 1];
  if (p1) drawLineSegment(p1, p2);
  points.push(p2);
});

canvas.addEventListener('mouseup', () => {
  drawing = false;
  points = [];
});
canvas.addEventListener('mouseout', () => {
  drawing = false;
  points = [];
});

// --- Touch events ---
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  drawing = true;
  points.push(getTouchPos(canvas, e));
});

canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  if (!drawing) return;
  const p2 = getTouchPos(canvas, e);
  const p1 = points[points.length - 1];
  if (p1) drawLineSegment(p1, p2);
  points.push(p2);
});

canvas.addEventListener('touchend', () => {
  drawing = false;
  points = [];
});
canvas.addEventListener('touchcancel', () => {
  drawing = false;
  points = [];
});

// --- Refresh button ---
document.getElementById('refreshButton').addEventListener('click', () => {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  hue = 0; // reset hue
});
</script>

</body>
</html>
